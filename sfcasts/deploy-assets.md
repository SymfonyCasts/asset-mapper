# Deploying the Assets

Coming soon...

So, how do we get our assets on this site? If you view source on this page, it actually looks like things are working. We can see our import map, we can see down here, and all these paths look the same, they all have the version file names in them. The problem is that these are all just 404ing. In the dev environment, there's some symphony code that will serve all of these files to us. But in the prod environment, that system isn't even active. It's too slow to run on production, so everything is just 404s. And that's okay. We learned a long time ago about a command that we can run to fix this. binconsole asset-map-compile. Very simply, this takes all of the assets that AssetMapper knows about and moves them into the public slash assets directory. It's not a command you'll need to run locally, but it is something that you're going to need to run on production. So, I'm going to copy that asset-map-compile, and we're going to head over to platform.app.yaml and go down to the build step. So, it's pretty cool. We're going to let symphony do its build thing, and then afterwards, we can just add our own stuff. So, phpbin slash console asset-map-compile. That should do it. So, let's go over here. Add that. White space bothers me. There we go. Give it a commit message, and then symphony deploy. And wait a minute or two for it to build that and get that deployed. And inside that, you can actually see the command running, compiling assets to public slash assets, compiled 16 assets. It also writes a couple of other files inside the public assets directory, manifest.json, import-map.json. These are not important, but symphony, because they're there, symphony is going to use them. It actually helps them dump the import map and the other files on the page even faster, so it doesn't have to do any calculations at all to write that. And done. Spin over and it still looks bad. But check this out, if you head to the home page under the console, our JavaScript is running. You can see that our console.log right there. So our JavaScript's running, but our CSS is missing. And you can see it right here. It's a 404 for our app.tail1.css.  Now remember the trick when you have 404s. If you don't see a versioned file name inside of there, it means that asset-mapper system's having trouble finding the file. Do you remember what the problem is? App.tail1.css is a file that we're building, and it's not committed to our repository. So we have this tail1 script going up here. I'll stop that and kind of rerun it. So we're building the app.tail1.css file. It's being ignored from Git. When you deploy with platform.sh, it's deploying from Git, so that file is simply missing. So not a big deal. This is another thing we're just gonna add to our build step. And effectively, and we're gonna need to do it before we run asset-map compile so that the file's available. I'm gonna paste the code in for this. And effectively, this is the same code that we ran earlier to get things set up locally, except that in this case I'm using the Linux x64 build. But we're downloading that during build. I'm moving it into the bin directory. Doesn't really matter where it goes. Making it executable, and then we are running that same command on its input and output so that the file's there, but it's by the time asset-map compile runs. All right, so back over here. Let's add that. Do I get it? You can actually see while it deploys there, this last time it was 16 files, now there's 17 files. And it looks like running tailwind will work just fine. Once that finishes, spin over, it's alive. Both pages, all the pages in our site are working with CSS. I love it. All right, so we're on production. It was really just as simple as making sure tailwind is being built in our case, and then you run the asset-map compile command. But there are two other things I want you to think about once you're on production. There are three things. First one was that your web server uses HTTP2. We talked about that earlier, so hopefully you already made sure that was the case. The second thing is that, notice that nothing in asset-mapper ever combined our files. And for the most part, they don't need to. We're going to talk more about that in a second, thanks to HTTP2. But there's also nothing that ever minified our files.  That's all. But in reality, we do want our CSS and JavaScript files to be minified, or if not minified, compressed. But this is something that can be done by our web server. So basically, we want our web server to compress the assets so that they're smaller when they're being sent to our user. This is something that all web servers support, and it's done automatically by Platform.sh. And here's how we can see it. If we go to Network Tools, and let's just go to JavaScript. Perfect. Let's find one of our JavaScript files here. Let's go to Headers. Let me make this a little bit bigger. And see this Content Encoding? That is compression. This BR stands for something called Brotli, which is a very advanced compression engine. The other thing that would work here is Gzip. So one of the things we get for free with Platform.sh is all of our static files are already being compressed, so we can check that thing off of our box. No. Minifying is a lot like compression, except that minifying also removes comments. That's not something that web servers do. If you use Cloudflare, they actually do have a way that you can do auto-minification and make your files even a little bit smaller if you want to. It's not something I worry about, but you can if you want to. All right, the second thing we want to worry about is we want to make sure that all of our static files have long-term expiration. So because we have these nice version file names, if I come to my site, I don't want my users to... I want my users to download this file one time and never download it again. I want them to cache it forever, because if we change any code inside this file, this whole file name's going to change, so naturally they're going to download that new file the next time they come to the site. So out of the box, this is again something you look at response headers, you're looking at expires. Out of the box, Platform.sh for static assets gives them about a one hour expires header. We can do much better than that. So this is going to be over in that Platform.app.yaml, up under locations. Here we go.  So you can see the expires is one hour. That's fine. We're going to leave that. We're going to put another little rule under here to be a little more specific. Here is a... Inside of here, we're going to put a little regular expression, so a URL that starts with slash assets slash anything, we're going to say expires 365 days. So basically, in the world of the internet, that's forever. So I'll commit that. Let's deploy that. Hopefully that's okay. All right, that finishes refresh. We're not going to see any difference, but let's check out one of our JavaScript files, app.js. And what we're looking for down here is, look at that, expire. So fired in the future. If you don't see that, do a force refresh because you might have actually the old cached version of the file from a second ago. But that's what I want to see. So our assets are being compressed. They have long live expires headers. We have checked all of our boxes for a performance site. But next, we're going to prove it by using a lighthouse to actually profile the performance in our site. We're going to learn a bunch about how files are downloaded and the pages are built and make our front end even more performant.
