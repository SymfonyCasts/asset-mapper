# Doing Modern JS Right in your Browser

Before we talk about anything Symfony related, let's first prove that we *can* code with modern JavaScript in our browser. Check this out! We're going to go *directly* into the `/public` directory and create a new `app.js` file. To start, we'll just `console.log()` a message. This won't be processed by Symfony or anything *yet*. We're keeping it simple.

In `/templates/base.html.twig`, up here in this JavaScript block, we're just going to add a boring `<script>` tag for this: `<script src="{{ asset('app.js') }}">`. We're using the `asset()` function, but that's not doing anything for us here. It's just going to output a `<script>` tag.

Back over in our browser, open the Console... and refresh. There we go! We got the log! *But* it's not super interesting yet. Now, let's go into `app.js` and write some modern JavaScript code. Copy the mix name here, and let's create a class. We'll say `class MixedVinyl`. We're using the ES syntax here. We'll quickly create a very simple class that takes a `title` and `year` constructor properties... sets those onto properties.... and then we'll add a little `describe()` method. This is going to use string interpolation (another modern JavaScript feature) to return a string. Cool! This is modern JavaScript - the kind of stuff that we write every day - and, historically, that hasn't worked in a browser.

Down here, let's use that. Say `const` (another modern JavaScript feature) `mix = new MixedVinyl`. Then we're going to pass it our mix name, the year, and finally, we'll `console.log(mix.describe)`. *Nice*. That's the way I like to write JavaScript. Normally, we would have a build system like Encore that would read this and change it to *old* JavaScript that would work in our browser. But... *surprise*! It *already* works in our browser. We don't need to do *anything*. That's not just because I'm using a new browser. This is going to work in *every* browser. If you're ever unsure, go to "caniuse.com" to check it out. Let's look up "ES6 class". ES6 is the version of ECMAScript that most of the modern JavaScript features you know and love came from. You can see here that this is supported *everywhere* except for IE 11, which is dead.

So... what *else* can we do? What about the `import` statement? Copy this `class MixedVinyl` here, and let's create another file directly inside of `/public` called `vinyl.js`. Paste this in here, and then we're going to `export` it. Say `export default class` and then, over in `app.js`, we'll then `import MixedVinyl from` and, just like normal JavaScript, we'll use the relative `./vinyl.js`. Notice that I'm including the `.js` here. We don't always do that. I'll talk more about that later, but know that I'm doing that on purpose.

In the past, this `import` statement wasn't supported, and when we refresh, we actually *do* get an error: "Cannot use import statement outside a module". This isn't a big deal. Back in `base.html.twig`, when we talk about "modules", we're talking about files that use `export` and `import`. If you want to load your JavaScript into a module system, your original `<script>` tag just needs to change a little. Copy this `asset()` function, and now we're going to say `<script type="module">`. And instead of `src`, inside, we're just going to write some JavaScript and `import` our `app.js` file. This looks kind of crazy, but it's just `import` with `''` like we're writing JavaScript, and then I'll use Twig to print out that path. So we're importing `app.js`, which will execute it as a module, and... everything works! Yes! Our browser supports the `import` statement.

We can also use third-party packages inside of a system like this. To find a third-party package, I'm going to use my favorite CDN called "jsDelivr". We'll be using this quite a bit throughout this tutorial. You don't *need* to rely on jsDelivr, but jsDelivr has a mirror of every single NPM package, so if you're looking for a NPM package that you want to use, this is a great place to go. Let's look at a popular library called "Lodash". If we select Lodash, you can see it has a `<script>` tag for us. Click on "ESM", which is the word for "modules". When you're coding with imports and exports, you want the *ESM* version of a package. And down here, you can see that it says:

`<script type="module">
import lodash from '[...]'
</script>`

This is showing us code that looks very similar to the code we had over here. We won't use that, but I *am* going to copy this URL. And check this out! If we go to `app.js`, we can say `import _ from` and paste that full URL. We can *also* download this file locally. I'll talk more about that later. We don't *have to* rely on a CDN, but it's *really* easy. Down here, let's say `_.camelCase` to call one of the methods on Lodash. Head back over, refresh, and... look at that!. There's no build system here. We just opened up these files inside of our `/public` directory, and we're even using third-party NPM packages. That's pretty amazing.

*However*, there are two problems with this. First of all, importing packages using the full URL like this is kind of annoying. I want to be able to simply say `import from lodash.` The *second* problem is asset versioning. In order to have an efficient system, we need the final files downloaded by the browser to have version hashes in the file name, like "app.1234abcd.js". We can't get that by just creating files in our `/public` directory.

These are two things that Symfony's new AssetMapper component is going to solve, but I wanted to start with raw JavaScript files so you can see that most of what we're going to be doing is not solved by Symfony or AssetMapper. It's just solved by your browser and the modern web. Yay!

Okay, before we hop into AssetMapper, I'm going to delete these two files so we don't get confused, and I'll also take out this `import` inside of our `base.html.twig` file. Don't worry! You'll see all of that code in a different way soon.

Next: Let's install AssetMapper and learn more about it.
