# JavaScript & importmap

Let's start by removing this `<img>` tag so we can actually see our normal page over here. There we go. And don't worry about our little penguin guy. We still have him up here in the logo. Right now, when we refresh the page, notice that we do have this `console.log` message, which tells us it's coming from `assets/app.js`. And if we head over to `assets/app.js`... there it is! We already know that we can write modern ES6 class codes in here, as well as import code. We're going to do *all* of that, but first: *How* and *why* is *this* file being executed? We know that, over in `/styles/app.js`, our CSS is being executed thanks to this nice, boring `<link>` tag up here. While we don't see a `<script>` tag down here in this JavaScript section, we *do* see this little `importmap()` function. *That's* the key.

Back over on our site, let's "View Page Source". Down here... *this* is what `importmap` is adding. We're going to talk about each part of this, but the most important thing I want you to look at right now is at the bottom:

`<script type="module">import 'app';</script>`

Earlier, when we created an `app.js` file inside of our `/public` directory, that's exactly how we did it. We used `import` and then the *path* to that file. But... wait a second. Is that *right*? It just says `app`. Shouldn't it say something like "/assets/app.something.js"? How does it know that `app` is actually referring to the final version of this file? *That* is where this `importmap` thing comes from up here.

This is generated from an `importmap.php` file inside of our project. This file isn't super interesting *yet*, but it'll be more useful soon when we talk about third party JavaScript packages. Right now, it *does* have this `app` key here that's pointing to the logical path to `app.js`. Thanks to that, this special `<script type='importmap'>` dumps onto the page. When you import something that doesn't start with a ".", "/", or "../", that's considered a *bare* import. We usually see this for third party libraries. But in the browser environment, when it sees a bare import, your browser looks for an `importmap` on the page to see if there's a matching import. Our browser sees `import 'app'`, finds this key here, and *that's* the path it downloads. This is basically like copying this path here and pasting it right there. That's why our `app.js` file is being executed. The `importmap()` outputs our `importmap`, but it *also* outputs this extra little `<script type="module">` to Bootstrap our application.

The great thing about `importmap` is that it's not a Symfony thing; It's just an *internet* thing. It's how your browser works. We *do* have this `importmap.php` file, which *is* a Symfony thing that we use to generate this. But once this is on the page, your *browser* is the star. It's doing all the work. And `importmap` works in *most* browsers. If you go to "caniuse.com" and search for "importmap", you can see that it works in about 81% of browsers. That's a *little*, but fortunately, `importmap` also dumps a *shim*. You can see that here. We're including an actual JavaScript file which, if your user's browser *doesn't* support `importmap`, *adds* that functionality. *That's* why you don't need to worry about browser support for `importmap`. It's *just* going to work. We'll talk more about `importmap` in a minute. When we start bringing in third party JavaScript, this gets *interesting*.

Let's go into `app.js` and add a little bit of modern code here. In fact, we're going to go into `/assets` and create a new directory called `/lib`. And inside *that*, create a new file called `vinyl.js`. Now we can paste in the same kind of simple class that we had earlier. Back over in `app.js`, we're just going to import that. Say `import Vinyl` and we can hit "tab" to autocomplete the `from '.lib/vinyl'`. We'll also instantiate this using the same stuff as before... and then add `console.log(mix.describe())`.

This is *great*. We're coding like we normally would, using `./`. But when we go over and refresh... it *doesn't* work. And check out this `404` to `/assets/lib/vinyl` coming from our `app.js` file. So... what's going on here? We'll talk more about debugging problems later, but here's a hint: If you ever see that your browser is trying to download a path that *doesn't* have a versioned file name, *something is wrong with your path* and you should check it for typos. *Our* problem is that we need to add the `.js`. Leaving the `.js` off is a Node thing, for when you're actually programming with the Node language. But in true JavaScript environments, like in your browser, you *should* include the `.js` extension. If we refresh now... it *works*.

If you want that to happen *automatically* via autocomplete, you can go into your PhpStorm settings and search for "use file extension". Go into "Code Style", "JavaScript", and change "Use file extension" to "Always". Check this out! If we say `import Vinyl` and hit "tab" again, *this* time, autocomplete added the `.js` on the end *for* us. Cool! It's working! But the fun doesn't stop there. Something else is happening behind the scenes. Click into this `console.log()` here as an easy way to see the source of our `app.js` file. If you look up here, this is exactly what our file looks like. You can see `import from './lib/vinyl.js'`. There's just one problem. That's not the final file name to `vinyl.js`.

If we go into our Network tools over here, go to "JS", and search for "vinyl"... check this out. *All* files served by AssetMapper have a versioned part of their file name. So... if *this* is the versioned file name, how the heck does our browser see `./lib/vinyl.js` and *know* that it should get this long file name? The *answer*, if you view the page source, is the `importmap`. This is *great*. The `importmap` is constructed from two sources. The *first* source is obvious - `importmap.php` - and we'll add more entries to this soon. The *second* source is a path which is added to the `importmap` *automatically* when your JavaScript imports *other* JavaScript using relative paths. This is really powerful because it means that your final code can look like `./lib/vinyl.js`, but it's *actually* reading that from the map and downloading the final file. So, once again, it's `importmap` to the rescue! That's an internal detail but it's cool to see how that works.

Okay, we've talked about `importmaps` a little, but we haven't really addressed the *biggest* superpower of them all, which is using third party packages. Let's do that *next*.
